#!/usr/bin/env python
# coding: utf-8

# # Исследование надежности заемщиков

# Это первая часть проекта, она будет проверена автоматически. Вторую часть проверит ревьюер. 

# ## Откройте таблицу и изучите общую информацию о данных

# **Задание 1. Импортируйте библиотеку pandas. Считайте данные из csv-файла в датафрейм и сохраните в переменную `data`. Путь к файлу:**
# 
# `/datasets/data.csv`

# In[1]:


import pandas as pd # импортируйте библиотеку pandas


# In[2]:


data = pd.read_csv('/datasets/data.csv')# прочитайте csv-файл


# **Задание 2. Выведите первые 20 строчек датафрейма `data` на экран.**

# In[3]:


data.head(20) # ваш код здесь


# **Задание 3. Выведите основную информацию о датафрейме с помощью метода `info()`.**

# In[4]:


data.info()# ваш код здесь


# ## Предобработка данных

# ### Удаление пропусков

# **Задание 4. Выведите количество пропущенных значений для каждого столбца. Используйте комбинацию двух методов.**

# In[ ]:


print(data.isna().sum()) # ваш код здесь


# **Задание 5. В двух столбцах есть пропущенные значения. Один из них — `days_employed`. Пропуски в этом столбце вы обработаете на следующем этапе. Другой столбец с пропущенными значениями — `total_income` — хранит данные о доходах. На сумму дохода сильнее всего влияет тип занятости, поэтому заполнить пропуски в этом столбце нужно медианным значением по каждому типу из столбца `income_type`. Например, у человека с типом занятости `сотрудник` пропуск в столбце `total_income` должен быть заполнен медианным доходом среди всех записей с тем же типом.**

# In[ ]:


# перебираем каждый тип занятости в наборе уникальных значений столба income_type
for d in data['income_type'].unique(): 
    # на каждом шаге цикла с помощью атрибута loc выбираем строки,
    # в которых в income_type текущий тип занятости (d) и есть пропуски в 'total_income'
    data.loc[(data['income_type'] == d) &  (data['total_income'].isna()), 'total_income'] =     data.loc[(data['income_type'] == d), 'total_income'].median()# ваш код здесь
    # и записываем в них медианное значение total_income среди строк с текущим типом занятости (d)


# ### Обработка аномальных значений

# **Задание 6. В данных могут встречаться артефакты (аномалии) — значения, которые не отражают действительность и появились по какой-то ошибке. Таким артефактом будет отрицательное количество дней трудового стажа в столбце `days_employed`. Для реальных данных это нормально. Обработайте значения в этом столбце: замените все отрицательные значения положительными с помощью метода `abs()`.**

# In[5]:


data['days_employed'] = data['days_employed'].abs()
data # ваш код здесь


# **Задание 7. Для каждого типа занятости выведите медианное значение трудового стажа `days_employed` в днях.**

# In[15]:


# перебираем каждый тип занятости в наборе уникальных значений столба days_employed
#for d in data['income_type'].unique(): 
    # на каждом шаге цикла с помощью атрибута loc выбираем строки,
    #median_value = data.loc[(data['income_type'] == d),'days_employed'].median() 
    # и записываем в них медианное значение days_employed среди строк с текущим типом занятости (d)
    #print(f'Медианное значение для занятости {d} - {median_value}')
    
    
print(data.groupby("income_type")["days_employed"].median())

# группируем данные по типу занятости и вычисляем медиану дней занятости
#grouped = data.groupby("income_type")["days_employed"].median()
# выводим результаты
#for income_type, median_value in grouped.items():
    #print(f"Медианное значение для занятости {income_type} - {median_value} дней")


# У двух типов (безработные и пенсионеры) получатся аномально большие значения. Исправить такие значения сложно, поэтому оставьте их как есть.

# **Задание 8. Выведите перечень уникальных значений столбца `children`.**

# In[20]:


print(data['children'].unique())# ваш код здесь


# **Задание 9. В столбце `children` есть два аномальных значения. Удалите строки, в которых встречаются такие аномальные значения из датафрейма `data`.**

# In[21]:


data = data.drop(data.index[data['children'].isin([-1, 20])])
# В этом коде мы используем метод `isin` для поиска индексов строк, в которых есть аномальные значения в столбце "children" (20 и 5), а затем вызываем метод `drop` для удаления # ваш код здесь


# **Задание 10. Ещё раз выведите перечень уникальных значений столбца `children`, чтобы убедиться, что артефакты удалены.**

# In[22]:


print(data['children'].unique())# ваш код здесь


# ### Удаление пропусков (продолжение)

# **Задание 11. Заполните пропуски в столбце `days_employed` медианными значениями по каждому типу занятости `income_type`.**

# In[ ]:


# перебираем каждый тип занятости в наборе уникальных значений столба income_type
for d in data['income_type'].unique(): 
    # на каждом шаге цикла с помощью атрибута loc выбираем строки,
    # в которых в income_type текущий тип занятости (d) и есть пропуски в 'days_employed'
    data.loc[(data['income_type'] == d) &  (data['days_employed'].isna()), 'days_employed'] =     data.loc[(data['income_type'] == d), 'days_employed'].median()# ваш код здесь
    # и записываем в них медианное значение total_income среди строк с текущим типом занятости (d)  # ваш код здесь


# **Задание 12. Убедитесь, что все пропуски заполнены. Проверьте себя и ещё раз выведите количество пропущенных значений для каждого столбца с помощью двух методов.**

# In[23]:


print(data.isna().sum()) # ваш код здесь


# ### Изменение типов данных

# **Задание 13. Замените вещественный тип данных в столбце `total_income` на целочисленный с помощью метода `astype()`.**

# In[25]:


data['total_income'] = data['total_income'].astype(int) # ваш код здесь


# ### Обработка дубликатов

# **Задание 14. Обработайте неявные дубликаты в столбце `education`. В этом столбце есть одни и те же значения, но записанные по-разному: с использованием заглавных и строчных букв. Приведите их к нижнему регистру.**

# In[ ]:


data['education'] = data['education'].str.lower() # ваш код здесь


# **Задание 15. Выведите на экран количество строк-дубликатов в данных. Если такие строки присутствуют, удалите их.**

# In[26]:


print(data.duplicated().sum()) # посчитайте дубликаты


# In[ ]:


data = data.drop_duplicates()  # удалите дубликаты


# ### Категоризация данных

# **Задание 16. На основании диапазонов, указанных ниже, создайте в датафрейме `data` столбец `total_income_category` с категориями:**
# 
# - 0–30000 — `'E'`;
# - 30001–50000 — `'D'`;
# - 50001–200000 — `'C'`;
# - 200001–1000000 — `'B'`;
# - 1000001 и выше — `'A'`.
# 
# 
# **Например, кредитополучателю с доходом 25000 нужно назначить категорию `'E'`, а клиенту, получающему 235000, — `'B'`. Используйте собственную функцию с именем `categorize_income()` и метод `apply()`.**

# In[ ]:


# создайте функцию categorize_income()
def categorize_income(total_income):
    if total_income <= 30000:
        return 'E'
    if total_income <= 50000:
        return 'D'
    if total_income <= 200000:
        return 'C'
    if total_income <= 1000000:
        return 'B'
    else:
        return 'A'


# In[ ]:


data['total_income_category'] = data['total_income'].apply(categorize_income) # примените функцию методом apply(


# **Задание 17. Выведите на экран перечень уникальных целей взятия кредита из столбца `purpose`.**

# In[ ]:


print(data['purpose'].unique())# ваш код здесь


# **Задание 18. Создайте функцию, которая на основании данных из столбца `purpose` сформирует новый столбец `purpose_category`, в который войдут следующие категории:**
# 
# - `'операции с автомобилем'`,
# - `'операции с недвижимостью'`,
# - `'проведение свадьбы'`,
# - `'получение образования'`.
# 
# **Например, если в столбце `purpose` находится подстрока `'на покупку автомобиля'`, то в столбце `purpose_category` должна появиться строка `'операции с автомобилем'`.**
# 
# **Используйте собственную функцию с именем `categorize_purpose()` и метод `apply()`. Изучите данные в столбце `purpose` и определите, какие подстроки помогут вам правильно определить категорию.**

# In[ ]:


def categorize_purpose(purpose):
    if 'автомоб' in purpose:
        return 'операции с автомобилем'
    elif 'недвиж' in purpose or 'жил' in purpose:
        return 'операции с недвижимостью'
    elif 'свадьб' in purpose:
        return 'проведение свадьбы'
    elif 'образ' in purpose:
        return 'получение образования'
    else:
        return 'нет категории'# создайте функцию categorize_purpose()


# In[ ]:


data['purpose_category'] = data['purpose'].apply(categorize_purpose) # примените функцию методом apply()
#print(data['purpose_category'].value_counts())

